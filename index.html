 <!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Slides â€” Google Slides-like Editor</title>
<script src="https://js.puter.com/v2/"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
<style>
  :root{
    --bg:#f1f3f4; --top:#ffffff; --accent:#1a73e8; --muted:#5f6368; --panel:#ffffff; --shadow: rgba(60,64,67,0.15);
    --left:#ffffff; --thumb-border:#e0e0e0; --slide-bg:#ffffff;
  }
  html,body{height:100%;margin:0;font-family:Roboto, Arial, sans-serif;background:var(--bg);color:#202124;}
  /* layout */
  .app{display:flex; flex-direction:column; height:100vh; overflow:hidden;}
  .topbar{height:64px; display:flex; align-items:center; gap:12px; padding:8px 16px; background:var(--top); box-shadow:0 1px 0 rgba(0,0,0,0.08); z-index:30;}
  .logo{display:flex; align-items:center; gap:8px;}
  .logo .dot{width:10px;height:10px;border-radius:2px;background:var(--accent);}
  .title-input{border:0; font-size:16px; font-weight:500; outline:none; width:320px;}
  .top-actions{margin-left:auto; display:flex; gap:8px; align-items:center;}
  button {background:transparent;border:0;padding:8px 12px;border-radius:4px;cursor:pointer;color:var(--muted);font-size:14px;}
  button:hover{background:rgba(60,64,67,0.06); color:#202124;}
  button.primary{background:var(--accent);color:white;font-weight:500}
  .toolbar-divider{width:1px;height:28px;background:#e8eaed;border-radius:2px;margin:0 6px;}
  .main{display:flex; flex:1; overflow:hidden;}
  .leftpane{width:260px; background:var(--left); border-right:1px solid var(--thumb-border); padding:12px; overflow:auto;}
  .left-actions{display:flex; gap:8px; margin-bottom:8px;}
  .thumbs{display:flex;flex-direction:column; gap:10px;}
  .thumb{background:linear-gradient(180deg, #fff, #fbfdff); border:1px solid #e3e6ea; border-radius:6px; padding:6px; cursor:pointer; display:flex; gap:8px; align-items:center; box-shadow:0 1px 2px var(--shadow);}
  .thumb.selected{outline:3px solid rgba(26,115,232,0.12);}
  .thumb .mini{width:120px; height:68px; background:#f8f9fa; border-radius:3px; overflow:hidden; display:flex; align-items:center; justify-content:center; color:#666; font-size:12px;}
  .thumb .meta{flex:1; font-size:12px; color:var(--muted);}
  .center{flex:1; display:flex; flex-direction:column; align-items:center; padding:20px; overflow:auto;}
  .canvas-wrap{width:100%; display:flex; justify-content:center; align-items:flex-start; padding:12px;}
  .slide-frame{width:1024px; height:576px; background:var(--slide-bg); border-radius:6px; box-shadow:0 8px 30px rgba(60,64,67,0.12); overflow:auto; position:relative; padding:28px; transform-origin:center;}
  .slide-frame [contenteditable="true"]{outline:none; min-height:18px;}
  .bottombar{height:44px; display:flex; align-items:center; gap:8px; padding:6px 12px; border-top:1px solid #e8eaed; background:#fff;}
  .small{font-size:13px;padding:6px 8px;border-radius:4px}
  /* modals */
  .modal-back{position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:60;}
  .modal{width:760px; background:white; border-radius:8px; padding:12px;}
  textarea{width:100%; min-height:160px; font-family:monospace; font-size:13px; padding:8px;}
  input[type=text]{padding:8px;border-radius:6px;border:1px solid #dadce0;width:100%;}
  /* presenter mode */
  .present-overlay{position:fixed; inset:0; background:black; display:none; align-items:center; justify-content:center; z-index:9999;}
  .present-slide{width:90vw;height:60vh;background:white;border-radius:6px;padding:28px; overflow:auto; box-shadow:0 20px 80px rgba(0,0,0,0.6);}
  .present-controls{position:fixed; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px; z-index:10000;}
  .present-counter{position:fixed; top:18px; right:24px; color:white; font-size:14px; z-index:10001;}
  /* responsive */
  @media(max-width:980px){ .leftpane{display:none} .slide-frame{width:720px;height:405px;} }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="logo"><div class="dot"></div><div style="font-weight:500">Slides</div></div>
    <input id="titleInput" class="title-input" placeholder="Untitled presentation" />
    <div class="top-actions">
      <button id="undoBtn" title="Undo">Undo</button>
      <button id="redoBtn" title="Redo">Redo</button>
      <div class="toolbar-divider"></div>
      <button id="presentBtn" class="primary" title="Present (Ctrl+Enter)">Present</button>
      <button id="saveBtn" title="Save">Save</button>
      <button id="insertHTML" title="Insert HTML">Insert HTML</button>
      <button id="aiInsert" title="AI Insert">AI</button>
      <div class="toolbar-divider"></div>
      <button id="shareBtn" title="Copy share link">Share</button>
    </div>
  </div>

  <div class="main">
    <div class="leftpane">
      <div class="left-actions">
        <button id="newSlide">+ New</button>
        <button id="dupSlideBtn">Dup</button>
        <button id="delSlideBtn">Del</button>
      </div>
      <div class="thumbs" id="slidesList" aria-label="Slides thumbnails"></div>
    </div>

    <div class="center">
      <div style="width:100%; display:flex; justify-content:center; margin-bottom:8px;">
        <div style="display:flex; gap:8px;">
          <button id="prevSlide" class="small">&larr;</button>
          <button id="nextSlide" class="small">&rarr;</button>
          <div style="align-self:center;color:var(--muted)">Slide <span id="currentIndex">1</span> / <span id="totalSlides">1</span></div>
        </div>
      </div>

      <div class="canvas-wrap">
        <div class="slide-frame" id="canvasArea" tabindex="0" aria-label="Slide editor">
          <!-- slide content -->
        </div>
      </div>

      <div class="bottombar">
        <div class="muted" id="saveStatus">Not saved</div>
        <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
          <div class="muted">Shareable link:</div>
          <input id="shareLink" type="text" readonly style="width:420px; border:1px solid #e8eaed; padding:6px; border-radius:6px;"/>
          <button id="copyLink" class="small">Copy</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- modal placeholder -->
<div id="modalRoot"></div>

<!-- presentation overlay -->
<div id="presentOverlay" class="present-overlay">
  <div class="present-counter" id="presentCounter"></div>
  <div class="present-slide" id="presentSlide"></div>
  <div class="present-controls" id="presentControls">
    <button id="prevPresent" class="small">Prev</button>
    <button id="exitPresent" class="small">Exit</button>
    <button id="nextPresent" class="small">Next</button>
  </div>
</div>

<script>
/* =========================
   CONFIG: JSONBin key (HARDCODED per user request)
   ========================= */
const JSONBIN_API = 'https://api.jsonbin.io/v3/b';
const MASTER_KEY = '$2a$10$w7kHZII5PZ.x1MhtZTBQm.WFZP1ZkfvsbDscb/WNBo9.0kmDtxgH.'; // <-- inserted as requested
// optional initial bin from hash
function parseHash(){ const h=location.hash.slice(1); const p=new URLSearchParams(h); return {bin:p.get('bin')||'', key:p.get('key')||''}; }
const hash = parseHash();
let INITIAL_BIN = hash.bin || null;
if (hash.key) {
  // if user also provided key in hash, it overrides hardcoded (keeps flexibility)
  // but per request we keep embedded key by default
  // MASTER_KEY = hash.key; // commented to preserve hardcoded per user's request
}

/* =========================
   App state
   ========================= */
function uuid(){ return 'id-'+Math.random().toString(36).slice(2,10); }
let state = {
  title: 'Untitled presentation',
  slides: [{ id: uuid(), html: '<h1 contenteditable="true">Welcome</h1><p contenteditable="true">Double-click to edit HTML. Use Insert HTML to paste markup.</p>' }],
  mainBinId: INITIAL_BIN || null,
  parts: null
};
let selectedIndex = 0;
let unsaved = false;

/* =========================
   DOM refs
   ========================= */
const slidesList = document.getElementById('slidesList');
const canvasArea = document.getElementById('canvasArea');
const titleInput = document.getElementById('titleInput');
const saveStatus = document.getElementById('saveStatus');
const shareLink = document.getElementById('shareLink');
const currentIndexEl = document.getElementById('currentIndex');
const totalSlidesEl = document.getElementById('totalSlides');
const presentOverlay = document.getElementById('presentOverlay');
const presentSlide = document.getElementById('presentSlide');
const presentCounter = document.getElementById('presentCounter');

/* =========================
   Utilities
   ========================= */
function bytesOf(str){ return new TextEncoder().encode(str).length; }
const MAX_PART_BYTES = 48000;

function updateShareLink(binId){
  const url = location.origin + location.pathname + '#bin=' + encodeURIComponent(binId||'') + '&key=' + encodeURIComponent(MASTER_KEY);
  shareLink.value = url;
}
function setSaveStatus(txt, busy=false){
  saveStatus.textContent = txt;
  if (!busy) unsaved = false;
}
function markUnsaved(){ unsaved = true; saveStatus.textContent = 'Unsaved changes'; }

/* =========================
   Render UI
   ========================= */
function renderList(){
  slidesList.innerHTML = '';
  state.slides.forEach((s,i)=>{
    const t = document.createElement('div');
    t.className = 'thumb' + (i===selectedIndex ? ' selected':'');
    t.dataset.index = i;
    t.innerHTML = `<div class="mini">${i+1}</div><div class="meta"><div style="font-weight:600">Slide ${i+1}</div><div style="color:var(--muted);font-size:12px">${stripText(s.html).slice(0,70) || 'Empty'}</div></div>`;
    t.addEventListener('click', ()=>{ selectedIndex = i; renderCanvas(); renderList(); });
    slidesList.appendChild(t);
  });
  currentIndexEl.textContent = selectedIndex+1;
  totalSlidesEl.textContent = state.slides.length;
}

function stripText(html){ return html.replace(/<[^>]*>/g,'').replace(/\s+/g,' ').trim(); }

function renderCanvas(){
  const data = state.slides[selectedIndex];
  canvasArea.innerHTML = data.html;
  // ensure elements are editable
  canvasArea.querySelectorAll('p,h1,h2,h3,div,span,li').forEach(el=>{
    if (!el.hasAttribute('contenteditable')) el.setAttribute('contenteditable','true');
  });
  // listen to input changes inside canvas to update state
  canvasArea.oninput = debounce(()=> {
    state.slides[selectedIndex].html = canvasArea.innerHTML;
    markUnsaved();
  }, 250);
  // double click to edit raw html
  canvasArea.ondblclick = ()=> openRawHtmlModal(selectedIndex);
}

/* =========================
   Slide operations
   ========================= */
function addSlide(afterIndex=null){
  const slide = { id: uuid(), html: '<h2 contenteditable="true">New Slide</h2><p contenteditable="true">Notes...</p>' };
  if (afterIndex===null) state.slides.push(slide);
  else state.slides.splice(afterIndex+1,0,slide);
  selectedIndex = (afterIndex===null) ? state.slides.length-1 : afterIndex+1;
  renderList(); renderCanvas(); markUnsaved();
}
function dupSlide(index=null){
  const i = index===null ? selectedIndex : index;
  const copy = { id: uuid(), html: state.slides[i].html };
  state.slides.splice(i+1,0,copy);
  selectedIndex = i+1;
  renderList(); renderCanvas(); markUnsaved();
}
function delSlide(index=null){
  const i = index===null ? selectedIndex : index;
  if (state.slides.length === 1){ alert('You must keep at least one slide.'); return; }
  if (!confirm('Delete slide '+(i+1)+'?')) return;
  state.slides.splice(i,1);
  selectedIndex = Math.max(0, i-1);
  renderList(); renderCanvas(); markUnsaved();
}

/* =========================
   Raw HTML modal / Insert HTML
   ========================= */
function openRawHtmlModal(index){
  const modalRoot = document.getElementById('modalRoot');
  modalRoot.innerHTML = `<div class="modal-back"><div class="modal"><h3>Edit raw HTML (slide ${index+1})</h3><textarea id="rawHtml">${escapeHtml(state.slides[index].html)}</textarea><div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px"><button id="rawCancel">Cancel</button><button id="rawSave" class="primary">Save</button></div></div></div>`;
  document.getElementById('rawCancel').onclick = ()=> { modalRoot.innerHTML=''; };
  document.getElementById('rawSave').onclick = ()=> {
    const val = document.getElementById('rawHtml').value;
    state.slides[index].html = val;
    modalRoot.innerHTML = '';
    renderList(); renderCanvas(); markUnsaved();
  };
}
function openInsertHtmlModal(){
  const modalRoot = document.getElementById('modalRoot');
  modalRoot.innerHTML = `<div class="modal-back"><div class="modal"><h3>Insert HTML into current slide</h3><textarea id="insHtml" placeholder="<div>HTML here</div>"></textarea><div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px"><button id="insCancel">Cancel</button><button id="insSave" class="primary">Insert</button></div></div></div>`;
  document.getElementById('insCancel').onclick = ()=> { modalRoot.innerHTML=''; };
  document.getElementById('insSave').onclick = ()=> {
    const html = document.getElementById('insHtml').value;
    state.slides[selectedIndex].html += '\n' + html;
    modalRoot.innerHTML = '';
    renderList(); renderCanvas(); markUnsaved();
  };
}
function escapeHtml(s){ return s.replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* =========================
   JSONBin save / load (single + split)
   ========================= */
async function buildHeaders(){ return { 'Content-Type':'application/json', 'X-Master-Key': MASTER_KEY }; }

async function createBin(payloadStr){
  const res = await fetch(JSONBIN_API, { method:'POST', headers: await buildHeaders(), body: payloadStr });
  if (!res.ok) throw new Error('Create failed: '+res.status);
  const j = await res.json();
  const id = j.record?.id || j.metadata?.id || j.id || (j?.data?.id) || null;
  return { id: id||j.id||null, raw:j };
}
async function putOrCreateBin(binId, payloadStr){
  if (binId){
    const res = await fetch(JSONBIN_API + '/' + encodeURIComponent(binId), { method:'PUT', headers: await buildHeaders(), body: payloadStr });
    if (res.ok){ const j = await res.json(); return { id: j.record?.id || j.metadata?.id || binId, raw: j }; }
    // fallback to create
    return await createBin(payloadStr);
  } else {
    return await createBin(payloadStr);
  }
}
function splitStringIntoChunks(str, maxBytes){
  const encoder = new TextEncoder(); const out=[]; let i=0;
  while (i<str.length){
    let j = Math.min(i+40000, str.length);
    while (j>i && encoder.encode(str.slice(i,j)).length > maxBytes) j--;
    if (j===i) throw new Error('Chunking error');
    out.push(str.slice(i,j)); i=j;
  }
  return out;
}

async function saveToJSONBin(){
  try {
    setSaveStatus('Saving...', true);
    const doc = { title: state.title, slides: state.slides };
    const jsonStr = JSON.stringify(doc);
    const size = bytesOf(jsonStr);
    if (size <= MAX_PART_BYTES){
      const saved = await putOrCreateBin(state.mainBinId, jsonStr);
      state.mainBinId = saved.id;
      state.parts = null;
      updateShareLink(state.mainBinId);
      setSaveStatus('Saved to ' + saved.id);
      return;
    }
    // too big: split into chunks and create bins
    const chunks = splitStringIntoChunks(jsonStr, MAX_PART_BYTES);
    const partIds = [];
    for (let i=0;i<chunks.length;i++){
      const created = await createBin(chunks[i]);
      partIds.push(created.id);
    }
    // save manifest in main bin
    const manifest = JSON.stringify({ type:'slides-manifest', title: state.title, parts: partIds, createdAt: new Date().toISOString() });
    const manifestSaved = await putOrCreateBin(state.mainBinId, manifest);
    state.mainBinId = manifestSaved.id;
    state.parts = { parts: partIds };
    updateShareLink(state.mainBinId);
    setSaveStatus('Saved (split into '+partIds.length+' parts). Manifest: ' + manifestSaved.id);
  } catch (err){
    console.error(err);
    setSaveStatus('Save failed: ' + (err.message || err));
    alert('Save failed: ' + (err.message || err));
  }
}

async function fetchRawBin(binId){
  const url = JSONBIN_API + '/' + encodeURIComponent(binId) + '/latest';
  const res = await fetch(url, { headers: { 'X-Master-Key': MASTER_KEY } });
  if (!res.ok) throw new Error('Failed fetch part '+binId+': '+res.status);
  return await res.json();
}

async function loadFromBin(binId){
  if (!binId) return;
  try {
    setSaveStatus('Loading...', true);
    const url = JSONBIN_API + '/' + encodeURIComponent(binId) + '/latest';
    const res = await fetch(url, { headers: { 'X-Master-Key': MASTER_KEY }});
    if (!res.ok) throw new Error('Load failed: '+res.status);
    const j = await res.json();
    await interpretLoadedData(j);
    setSaveStatus('Loaded ' + binId);
  } catch (err){
    console.error(err);
    setSaveStatus('Load failed: ' + (err.message || err));
    alert('Load failed: ' + (err.message || err));
  }
}

async function interpretLoadedData(j){
  let payload = null;
  if (j.record?.data) payload = j.record.data;
  else if (j.record?.json) payload = j.record.json;
  else if (j.record?.content) payload = j.record.content;
  else if (j.record) payload = j.record;
  else payload = j;
  if (typeof payload === 'object' && payload.type === 'slides-manifest' && payload.parts && Array.isArray(payload.parts)){
    const parts = payload.parts;
    const arr = [];
    for (const p of parts){
      const r = await fetchRawBin(p);
      let piece = r.record?.data || r.record || r;
      if (typeof piece === 'object') piece = JSON.stringify(piece);
      arr.push(piece);
    }
    const full = arr.join('');
    const parsed = JSON.parse(full);
    state.title = parsed.title || state.title;
    state.slides = parsed.slides || [];
    state.mainBinId = j.record?.id || j.metadata?.id || state.mainBinId;
    state.parts = { parts };
    renderList(); renderCanvas();
    updateShareLink(state.mainBinId);
  } else {
    let doc = null;
    if (typeof payload === 'string'){
      try { doc = JSON.parse(payload); } catch(e){ doc = payload; }
    } else doc = payload;
    if (doc && doc.slides){
      state.title = doc.title || state.title;
      state.slides = doc.slides;
      state.mainBinId = j.record?.id || j.metadata?.id || state.mainBinId;
      state.parts = null;
      renderList(); renderCanvas(); updateShareLink(state.mainBinId);
    } else {
      // unknown shape: put raw into a slide
      state.slides = [{ id: uuid(), html: '<pre contenteditable="true">' + escapeHtml(JSON.stringify(payload, null, 2)) + '</pre>' }];
      renderList(); renderCanvas();
    }
  }
}

/* =========================
   AI helper (Puter.js best-effort)
   ========================= */
async function tryPuter(prompt){
  if (!window.Puter) throw new Error('Puter not found on window. Include Puter.js to use AI.');
  const put = window.Puter;
  const candidates = ['query','ask','complete','generate','run','create'];
  for (const fn of candidates){
    if (typeof put[fn] === 'function'){
      try { return await put[fn](prompt); } catch(e){ console.warn('Puter method failed',fn,e); }
    }
  }
  if (typeof put === 'function') return await put(prompt);
  throw new Error('No usable Puter API found');
}

/* =========================
   Presentation mode
   ========================= */
let presenting = false;
let presentIndex = 0;
function openPresentation(startIndex=0){
  presenting = true; presentIndex = startIndex; renderPresent();
  presentOverlay.style.display = 'flex';
  document.addEventListener('keydown', presentKeyHandler);
  // request fullscreen for immersive presenter mode if available
  try { document.documentElement.requestFullscreen?.(); } catch(e){}
}
function closePresentation(){
  presenting = false;
  presentOverlay.style.display = 'none';
  document.removeEventListener('keydown', presentKeyHandler);
  try { document.exitFullscreen?.(); } catch(e){}
}
function renderPresent(){
  const slide = state.slides[presentIndex];
  presentSlide.innerHTML = slide ? slide.html : '';
  // make present slide static (remove contenteditable)
  presentSlide.querySelectorAll('[contenteditable]').forEach(el=> el.removeAttribute('contenteditable'));
  presentCounter.textContent = (presentIndex+1) + ' / ' + state.slides.length;
}
function presentKeyHandler(e){
  if (!presenting) return;
  if (e.key === 'ArrowRight' || e.key === 'PageDown') { nextPresent(); }
  else if (e.key === 'ArrowLeft' || e.key === 'PageUp') { prevPresent(); }
  else if (e.key === 'Escape') { closePresentation(); }
}
function nextPresent(){ presentIndex = Math.min(state.slides.length-1, presentIndex+1); renderPresent(); }
function prevPresent(){ presentIndex = Math.max(0, presentIndex-1); renderPresent(); }

/* =========================
   Event wiring
   ========================= */
document.getElementById('newSlide').addEventListener('click', ()=> addSlide(selectedIndex));
document.getElementById('dupSlideBtn').addEventListener('click', ()=> dupSlide());
document.getElementById('delSlideBtn').addEventListener('click', ()=> delSlide());
document.getElementById('prevSlide').addEventListener('click', ()=> { selectedIndex = Math.max(0, selectedIndex-1); renderList(); renderCanvas(); });
document.getElementById('nextSlide').addEventListener('click', ()=> { selectedIndex = Math.min(state.slides.length-1, selectedIndex+1); renderList(); renderCanvas(); });
document.getElementById('saveBtn').addEventListener('click', ()=> saveToJSONBin());
document.getElementById('insertHTML').addEventListener('click', ()=> openInsertHtmlModal());
document.getElementById('aiInsert').addEventListener('click', async ()=>{
  try {
    const prompt = `Generate a short HTML slide for a presentation titled "${state.title}". Output only the HTML. Keep it concise.`;
    const out = await tryPuter(prompt);
    const html = (typeof out === 'string') ? out : (out?.text || out?.result || JSON.stringify(out));
    state.slides[selectedIndex].html += '\n' + html;
    renderCanvas(); markUnsaved();
  } catch (err){
    alert('AI failed: ' + (err.message || err));
  }
});
document.getElementById('titleInput').addEventListener('input', (e)=> { state.title = e.target.value; markUnsaved(); });

document.getElementById('presentBtn').addEventListener('click', ()=> openPresentation(selectedIndex));
document.getElementById('exitPresent').addEventListener('click', ()=> closePresentation());
document.getElementById('prevPresent').addEventListener('click', ()=> prevPresent());
document.getElementById('nextPresent').addEventListener('click', ()=> nextPresent());

document.getElementById('shareBtn').addEventListener('click', ()=> {
  updateShareLink(state.mainBinId || '');
  navigator.clipboard.writeText(shareLink.value).then(()=> alert('Share link copied'));
});
document.getElementById('copyLink').addEventListener('click', ()=> {
  updateShareLink(state.mainBinId || '');
  navigator.clipboard.writeText(shareLink.value).then(()=> alert('Copied'));
});

/* keyboard shortcuts */
document.addEventListener('keydown', (e)=>{
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter'){ e.preventDefault(); openPresentation(selectedIndex); }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); saveToJSONBin(); }
  if (e.key === 'ArrowRight'){ /* navigate slide in editor */ }
});

/* before unload warn */
window.addEventListener('beforeunload', function(e){
  if (unsaved){ e.preventDefault(); e.returnValue = ''; }
});

/* =========================
   Init: render and try load if bin present
   ========================= */
function init(){
  titleInput.value = state.title;
  renderList();
  renderCanvas();
  updateShareLink(state.mainBinId || '');
  if (state.mainBinId) loadFromBin(state.mainBinId);
}
init();

/* =========================
   small helpers
   ========================= */
function debounce(fn,ms=200){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms);} }
function escapeHtml(s){ return s.replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

</script>
</body>
</html>
